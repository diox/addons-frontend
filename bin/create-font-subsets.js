#!/usr/bin/env node
/* eslint-disable no-console */
const fs = require('fs');

const { oneLine } = require('common-tags');
const prettier = require('prettier');
const shell = require('shelljs');
const chalk = require('chalk');
const deepEqual = require('deep-eql');

// Mapping between languages and the unicode ranges we want for the
// corresponding subset. The keys are languages (typically 2 character codes)
// separated by ',' when multiple need to be specified for a given subset.
const subsetsRanges = {
  en: `U+A, U+20-7E, U+2010-2014, U+2018, U+2019, U+201C-201E, U+2026,
       U+20AC, U+A3, U+A7, U+A9, U+AE, U+B0-B5, U+D7, U+F7, U+A0, U+2122,
       U+2032-2033, U+AB, U+BB, U+2080`,
  de: `U+A, U+20-7E, U+2010-2014, U+2018, U+2019, U+201C-201E,U+2026,
       U+20AC, U+A3, U+A7, U+A9, U+AE, U+B0-B5, U+D7, U+F7, U+A0, U+2122,
       U+2032-2033, U+AB, U+BB, U+2080,
       U+C4, U+D6, U+DC, U+DF, U+E4, U+F6, U+FC, U+201A`,
  fr: `U+A, U+20-7E, U+2010-2014, U+2018, U+2019, U+201C-201E,U+2026,
       U+20AC, U+A3, U+A7, U+A9, U+AE, U+B0-B5, U+D7, U+F7, U+A0, U+2122,
       U+2032-2033, U+AB, U+BB, U+2080,
       U+B2-B3, U+C0, U+C2, U+C6-CF, U+D4, U+D9, U+DB-DC, U+E0, U+E2, U+E6-EB,
       U+EE-EF, U+F4, U+F9, U+FB-FC, U+FF, U+152-153, U+178, U+202F`,
  ru: `U+A, U+20-7E, U+2010-2014, U+2018, U+2019, U+201C-201E, U+2026,
       U+20AC, U+A3, U+A7, U+A9, U+AE, U+B0-B5, U+D7, U+F7, U+A0, U+2122,
       U+2032-2033, U+AB, U+BB, U+2080,
       U+401, U+410-44F, U+451`,
  es: `U+A, U+20-7E, U+2010-2014, U+2018, U+2019, U+201C-201E, U+2026,
       U+20AC, U+A3, U+A7, U+A9, U+AE, U+B0-B5, U+D7, U+F7, U+A0, U+2122,
       U+2032-2033, U+AB, U+BB, U+2080,
       U+A1, U+BF, U+C1, U+C9, U+CD, U+D1, U+D3, U+DA, U+DC, U+E1, 
       U+E9, U+ED, U+F1, U+F3, U+FA, U+FC`,
  pt: `U+A, U+20-7E, U+2010-2014, U+2018, U+2019, U+201C-201E, U+2026,
       U+20AC, U+A3, U+A7, U+A9, U+AE, U+B0-B5, U+D7, U+F7, U+A0, U+2122,
       U+2032-2033, U+AB, U+BB, U+2080,
       U+C0-C3, U+C7, U+C9-CA, U+CD, U+D2-D5, U+DA, U+E0-E3, U+E7, U+E9-EA,
       U+ED, U+F2-F5, U+FA`,
  pl: `U+A, U+20-7E, U+2010-2014, U+2018, U+2019, U+201C-201E, U+2026,
       U+20AC, U+A3, U+A7, U+A9, U+AE, U+B0-B5, U+D7, U+F7, U+A0, U+2122,
       U+2032-2033, U+AB, U+BB, U+2080,
       U+B0, U+D3, U+F3, U+104-107, U+118-119, U+141-144, U+15A-15B,
       U+179-17C`,
  it: `U+A, U+20-7E, U+2010-2014, U+2018, U+2019, U+201C-201E, U+2026,
       U+20AC, U+A3, U+A7, U+A9, U+AE, U+B0-B5, U+D7, U+F7, U+A0, U+2122,
       U+2032-2033, U+AB, U+BB, U+2080,
       U+C0, U+C8-C9, U+CC, U+D2-D3, U+D9, U+E0, U+E8-E9, U+EC, U+F2-F3, U+F9`,
};

// Order for the mapping above. This matters because the browsers will pick the
// latest font in the file that has the unicode range needed, so the smallest,
// more restricted subsets need to be specified *last*. English is likely to
// be at the bottom for that reason.
// FIXME: should we do that automatically, just sorting by size ?
const subsetsOrder = [
  'it',
  'pl',
  'pt',
  'es',
  'ru',
  'fr',
  'de',
  'en',
];

if (!deepEqual(Object.keys(subsetsRanges).sort(), Object.values(subsetsOrder).sort())) {
  console.error(chalk.red(
    'Keys in subsetsRanges need to be in subsetsOrder and vice versa'));
  process.exit(1);
}

const output = [
  `/*
  DO NOT EDIT, THIS FILE IS AUTOMATICALLY GENERATED BY bin/create-font-subsets.

  Minimal font subsets for various languages.

  Each subset has different unicode-range that was crafted by running
  glyphhanger --onlyVisible --family="Inter var" on various pages, looking up
  the language in https://character-table.netlify.app/, and then manually
  tweaking the ranges to add extra characters we know that are likely to appear
  in pages in those languages.

  In serverHtml component, we preload subsets corresponding to the language,
  so a request for /en-US/something would preload the "en" font because of
  its name.

  The order of the various @font-face declarations matter: browsers will pick
  the latest font that has the unicode range needed, so the most specific
  subsets need to appear at the bottom.
*/
  `,
];

subsetsOrder.forEach((langOrLangs) => {
  // All langs need to be surrounded by `_` for easy matching later (_ was
  // chosen because it's URL safe)
  const sourceFilename = 'Inter-roman.var.woff2'
  const destinationFilename = (
    `Inter-roman-minimal_${langOrLangs.replace(/,/g, '_')}_subset.var.woff2`
  );

  console.log(`Creating subset for ${langOrLangs}`);
  // Fire pyftsubset to generate the subset. To make file size small we only
  // care about kerning in terms of layout features and we don't want hinting.
  const command = oneLine`pyftsubset src/fonts/woff2/${sourceFilename}
    --output-file="src/fonts/woff2/${destinationFilename}"
    --flavor=woff2
    --layout-features=kern
    --no-hinting
    --unicodes="${subsetsRanges[langOrLangs]}"`;

  console.log(command);
  shell.exec(command);

  // Generate the corresponding CSS
  output.push(
  `
    @font-face {
      font-family: 'Inter var';
      font-style: normal;
      font-weight: 100 900;
      src: url('woff2/${destinationFilename}') format('woff2');
      unicode-range: ${subsetsRanges[langOrLangs]};
    }
  `);
});

const runPrettierWithConfig = (text) => {
  const filePath = prettier.resolveConfigFile.sync();
  const options = prettier.resolveConfig.sync(filePath);
  return prettier.format(text, { ...options, parser: 'scss' });
}

// Put it all together
const prettyOutput = runPrettierWithConfig(output.join('\n'));
fs.writeFileSync('src/fonts/inter-subsets.scss', prettyOutput);
